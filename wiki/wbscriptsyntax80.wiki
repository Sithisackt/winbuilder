<h1>Script Syntax Changes that appear in version 080</h1>
<wiki:toc max_depth="2" />

This page describes new functionalty introduced with WinBuilder 080.
Older WinBuilder versions cannot work with this functionality.

There are new commands in the following categories
 * Registry handling
 * IF Clauses
 * Miscellaneous commands

<br>
----
=Registry Handling =

These commands are written to write and read values from the local registry on your windows machine. You can also load the hives from the projects being built at any given time.

These registry operations are valid for any Windows Platform, you should however note that Vista restricts the specific operation to load/unload hives - it is necessary to disable the UAC (User Account Control) before running projects that need this support.

==!RegWriteBin / !RegWriteBinEx==
{{{
RegWriteBin,<HKEY>,<KeyType>,<Section>,<Keyname>,<Value> 
}}}
This command will create a new or overwrite an existing registry entry as specified. The command is used to write Wide Strings (e.g. Unicode) into the registry. The wide string is defined by a series of hexadecimal values, separated by comma.

!RegWriteBinEx has the same syntax, but writes every value of every type unchecked into the registry.
It is in the responsibility of the script's author to make shure� that only valid registry entries are created. 

HKEY is the "Hive Key" where the key is to be placed. These hives are files that are loaded by your machine when booting and compose the registry structure. By default, most scripts use�HKLM as the work hive.

Valid HKEY values
 * HKLM
 * HKCU
 * HKCR
 * HKEY_USERS
 * HKEY_CURRENT_CONFIG

KeyType will specify how the data in the registry key should be interpreted. Valid key type values for RegWriteBin
 * 0x1 - String - writes a text value
 * 0x2 - Expanded String - will expand any variable value contained inside %%. (e.g. %temp%)
 * 0x7 - Writes multiple NULL separated strings
Section is the complete path to the section where the key is supposed to be written

Keyname is the name of the name of one of the 'child keys' of a section. Value can be
 * an explicitelly written list of hexadecimal values, separated by comma
 * a variable containing the list. Instead of the comma the variable must contain the escape #$c

The substrings of a 0x7 entry can be divided by ",00,00" bytes (without the quotes) or by the escape #$z. 

===Examples:===
{{{
RegWriteBin,HKLM,0x2,WB-Software\SOFTWARE\Classes\.bfc\ShellNew,Command,25,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,00,00 
Set,%Value%,25#$c00#$c53#$c00#$c79#$c00#$c73#$c00#$c74#$c00#$c65#$c00#$c6d#$c00#$c52#$c00#$c6f#$c00#$c6f#$c00#$c00#$c00
RegWriteBin,HKLM,0x2,WB-Software\SOFTWARE\Classes\.bfc\ShellNew,Command,%Value%
}}}

==!RegReadBin==
{{{
RegRead,<HKEY>,<Section>,<Key>,<%Variable%> 
}}}
This command will read a value from the key you specify.

It uses the same components as described above with the difference that it will copy the value of a key into a variable.

This command will only retrieve values from the following keytypes:
 * 0x1 - String
 * 0x2 - Expandable String
 * 0x7 - Multiple String

=== Example: ===
{{{
RegReadBin,HKLM,WB-Software\SOFTWARE\Classes\.bfc\ShellNew,Command,%Value%
}}}
In this example the variable %Value% will store the value of the mentioned key 

==!RegMulti==

These commands uses the same components as described above.
 * Writes a string at the specified place. If the string already exists in the current value, a warning is written and the current value is left unchanged.
{{{
RegMulti,<HKEY>,<Section>,<Key>,APPEND,<String>
RegMulti,<HKEY>,<Section>,<Key>,PREPEND,<String>
RegMulti,<HKEY>,<Section>,<Key>,BEFORE,<SubString>,<String>
RegMulti,<HKEY>,<Section>,<Key>,BEHIND,<SubString>,<String>
RegMulti,<HKEY>,<Section>,<Key>,PLACE,<Index>,<String>
}}}
 * Removes the specified substring.
{{{
RegMulti,<HKEY>,<Section>,<Key>,DELETE,<SubString>
}}}
 * Queries the index of the specified string. If the substring does not exist, the returned value is 0.
{{{
RegMulti,<HKEY>,<Section>,<Key>,INDEX,<SubString>,%Index%
}}}

<br>
----
=If Clauses =

The following two conditional tests were added in Version 80

==!ExistRegMulti==
{{{
If,ExistRegMulti,<HKEY>,<Section>,<Key>,<SubString>,<Command>
}}}
The command checks for the existence of a substring in a multiple string

=== Example: ===
{{{
If,EXISTREGMULTI,HKLM,SYSTEM\ControlSet001\Control\ServiceGroupOrder,List,"FSFilter Infrastructure",Echo,YES
}}}

==!ExistMacro==
{{{
If,ExistMacro,<Macro>,<Command>
}}}
The command checks whether the macro is defined in the [Variables] section.

<br>
----
=Miscellaneous Commands =
Under this category you find the commands which aren't grouped under any specific category but are still quite used on most scripting tasks.

==!AddInterface==
{{{
AddInterface,<Script>[,<Interface>],<prefix>�
}}}
Use this command to add the values of an interface to the variables List.
The optional `<Interface>` is used to read alternative interfaces, e.g. [Interface-Language]  The default value is to use the standard interface (`[Interface]`).

The prefix is used to distinguish to already existing interface values of the same name. The generated variables can be used as `%<prefix>_<original name>%`. If prefix is omitted, also the underline in the name of the generated variables is omitted.

=== Example: ===
{{{
AddInterface,%ScriptFile%,Interface-German,DE
}}}
Values of the German interface are now accessable like
{{{
Echo,%DE_pTextBox1%
}}}
if instead you used
{{{
AddInterface,%ScriptFile%,Interface-German,
}}}
Values of the German interface are now accessable like
{{{
Echo,%pTextBox1%
}}}